# -*- coding: utf-8 -*-
"""ham_spam_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T09OUZcU2dUHxNxg-w0V1peL34wmt28n
"""

from flask import Flask, render_template, request, redirect, url_for, session, flash
import pickle
import numpy as np
import pandas as pd

# ***Code to read in model, accept user input written in index.html, and predict using model***

app = Flask(__name__)
app.secret_key = "a_little_helpful"

# Model's features that will appear on the form
FORM_FIELDS = ["word_freq_address", "word_freq_3d",
               "word_freq_you", "word_freq_your", "word_freq_font",
               "word_freq_hp", "word_freq_george",
               "word_freq_re", "word_freq_edu", "capital_run_length_average",
               "capital_run_length_longest", "capital_run_length_total"]

def make_prediction(form_data):
    pred = None

    def require_float(name):
        # Fail fast so we don't silently use zeros
        val = form_data.get(name, None)
        if val is None or str(val).strip() == "":
            raise ValueError(f"Missing value for '{name}'")
        try:
            return float(val)
        except ValueError:
            raise ValueError(f"Invalid number for '{name}': {val}")


    # Ensures entry is floating point number if they enter integer
    def to_float(x, default=0.0):
        try:
            return float(x)
        except (TypeError, ValueError):
            return default

    TRAIN_COLS = ["word_freq_address", "word_freq_3d", "word_freq_you",
                  "word_freq_your", "word_freq_font", "word_freq_hp",
                  "word_freq_george", "word_freq_re", "word_freq_edu",
                  "capital_run_length_average", "capital_run_length_longest",
                  "capital_run_length_total"]

    # Build a row in the exact training order
    row = {c: float(form_data[c]) for c in TRAIN_COLS}
    X_df = pd.DataFrame([row], columns=TRAIN_COLS)

    # Predict ham or spam. Model is Random Forest, so no need to scale data
    prediction = final_model.predict(X_df)
    prediction_result = "ham" if prediction[0] == 0 else "spam"
    return f"Predicted ham or spam: {prediction_result}"

# Load model, scaler, and encoders
try:
  final_model = pickle.load(open('final_model.pkl', 'rb'))
except FileNotFoundError as e:
    raise Exception(f"Pickle file not found: {str(e)}")
except Exception as e:
    raise Exception(f"Error loading pickle file: {str(e)}")

@app.route('/', methods=["GET", "POST"])
def index():
    if request.method == "POST":
        # which button did they click?
        if "predict" in request.form:

            # keep submitted values in session
            session["form_values"] = {i: request.form.get(i, "") for i in FORM_FIELDS}

            # run prediction
            session["prediction"] = make_prediction(session["form_values"])

            # redirect to avoid resubmission on refresh
            return redirect(url_for("index"))

        if "clear" in request.form:
            session.pop("form_values", None)
            session.pop("prediction", None)
            return redirect(url_for("index"))

    # GET: render with whatever is in session (or defaults)
    values = session.get("form_values", {i: "" for i in FORM_FIELDS})
    prediction = session.get("prediction")
    return render_template("index.html", values=values, prediction=prediction)

if __name__ == '__main__':
    app.run(debug=True)